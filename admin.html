<title>Hanoi Admin</title>
<meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<link rel="stylesheet" href="style.css">
<style>
    body {
        display: flex;
        flex-direction: column;
        align-items: start;
        gap: 30px;
        padding: 20px;
    }

    #msg {
        color: blue;
    }

    input[type = password] {
        height: 40px;
        width: 300px;
        padding: 10px;
        border: 3px solid red;
    }

    button {
        padding: 8px;
        margin: 4px;
        font-size: 14px;
        border-radius: 8px;
    }

    button:hover:not(:disabled) {
        opacity: 0.8;
    }

    button:disabled, button[disabled] {
        opacity: 0.4;
        cursor: auto;
    }

    .segment {
        display: inline-flex;
        flex-direction: row;
        gap: 0;
    }

    .segment > button {
        box-sizing: content-box;
        padding: 6px 12px;
        border: #322641 solid 1px;
        border-radius: 0;
        margin: 0;
        margin-left: -1px;
        font-family: "Noto Emoji", "Open Sans", "Microsoft JhengHei", dotum;
        color: #322641;
        background-color: transparent;
    }

    .segment > button:hover {
        color: white;
        background-color: #322641 !important;
        opacity: 1;
    }

    .segment > button.selected {
        background-color: rgb(179, 255, 179);
    }

    #logs {
        width: 100%;
        white-space: nowrap;
        overflow: auto;
    }

    #logs p {
        font-family: "Montserrat", monospace;
    }

    div:has(.table) {
        width: 100%;
    }

    .table {
        display: block;
        overflow-x: auto;
        white-space: nowrap;
        border-spacing: 1px;
        font-size: 14px;
    }

    .table td:nth-child(n-1) {
        font-family: "Montserrat", monospace;
    }

    .table td {
        padding: 0px 10px;
        text-align: center;
    }
    
    .table button {
        font-size: 14px;
        padding: 4px 8px;
    }

    #popup {
        position: absolute;
        top: 24px;
        left: 50%;
        transform: translateX(-50%);
        padding: 8px;
        z-index: 99;
        width: fit-content;
        color: white;
        background-color: green;
        display: none;
    }
</style>
<body>
    <h2>Admin Dashboard</h2>
    <div>
        <p>Verify your identity:</p>
        <input id="password" type="password">
        <button id="button-verify" onclick="checkAdmin()">Send to server</button>
    </div>
    <div>
        <h2 id="msg"></h2>
        <h4>Connection status: <span id="connection-status"></span></h4>
        <h4>Input access: <span id="input-access"></span></h4>
        
        <button style="background-color: red;" onclick="configUpdate({ inputAccess: 'none' })">Lock</button>
        <button style="background-color: #1896bb;" onclick="configUpdate({ inputAccess: 'restricted' })">Restrict</button>
        <button style="background-color: #2e9a2e;" onclick="configUpdate({ inputAccess: 'everyone' })">Unlock</button>
        
        <h4 style="color: gray;">Output access (uneditable): <span id="output-access"></span></h4>
    </div>
    <div id="instance-management">
        <h2>Instance Management</h2>
        <button onclick="instanceUpdate(createNewInstance)">Create new</button>
        <div id="instances" class="segment"></div>
        <button onclick="instanceUpdate(importAndOverwrite)">Import and overwrite</button>
        <button onclick="instanceUpdate(deleteInstance)">Delete an instance</button>
        <button onclick="instanceUpdate(cloneInstance)">Clone to</button>
    </div>
    <div id="access-control">
        <h2 style="display: inline">Access Control</h2>
        <button onclick="createToken()">Create Token</button>
    </div>
    <div id="client-management">
        <h2>Connected Clients</h2>
        <div>
            <table class="table">
                <thead>
                    <tr>
                        <th>Connected</th>
                        <th>Platform</th>
                        <th>Role</th>
                        <th>Input Permission</th>
                        <th>Action</th>
                        <th>Full ID</th>
                    </tr>
                </thead>
                <tbody id="clients-data"></tbody>
            </table>
        </div>
    </div>
    <button onclick="window.location.href = './'" style="background-color: rgb(0, 30, 181);">Back to controller</button>
    <div id="logs"></div>
    <div id="popup">
        Testing 1 2 3.
    </div>
</body>

<script>
    const _ = (str, seed = 0) => {
        let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1  = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
        h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
        h2  = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
        h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    
        return 4294967296 * (2097151 & h2) + (h1 >>> 0);
    };
    const __ = (str) => _(str, _(str));
    
    const websocket = (() => {
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const host = window.location.host;
        const wsUrl = `${protocol}//${host}/ws`;
        return new WebSocket(wsUrl);
    })();

    var info = {
        connectionStatus: "not connected",
    }

    var serverConfig = {
        inputAccess: "unknown",
        outputAccess: "unknown",
    }

    function updateInfo() {
        document.getElementById("connection-status").innerText = info.connectionStatus;
        document.getElementById("input-access").innerText = serverConfig.inputAccess;
        document.getElementById("output-access").innerText = serverConfig.outputAccess;

        if (info.connectionId == "unknown") return;
    }

    async function req(url, method, data) {
        if (url.startsWith("/")) url = url.slice(1);
        const response = await fetch(`${window.location.protocol}//${window.location.host}/${url}`, {
            method,
            headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${__(document.getElementById("password").value)}`
            },
            body: JSON.stringify(data)
        });
        if (response.ok) {
            report("Success", 1);
        } else {
            report(`[${response.status}] ${await response.text()}`, 0, log = true);
        }
        waiting = false;
        document.getElementById("instance-management").style.opacity = 1;
    }

    function report(msg, type, log = false) {
        let color = type === null || type === undefined ? "gray" : type ? "green" : "red";
        document.getElementById("popup").style.backgroundColor = color;
        document.getElementById("popup").innerText = msg;
        document.getElementById("popup").style.display = "block";
        setTimeout(() => {
            document.getElementById("popup").style.display = "none";
        }, 3000);
        if (log) {
            pushLog(msg);
        }
    }

    function checkAdmin() {
        websocket.send(`ADMIN:${__(document.getElementById("password").value)}`);
    }

    function createNewInstance() {
        const name = prompt("Enter name for new instance:");
        if (name === null) return null;
        // websocket.send(`ADMIN:inst-create:${name}`);
        req("/api/instance/create", "POST", { name });
    }

    function importAndOverwrite() {
        const data = prompt("Enter JSON of data:");
        if (data === null) return null;
        // websocket.send(`ADMIN:inst-import:${data}`);
        req("/api/instance/import", "POST", { data: JSON.parse(data) });
    }

    function deleteInstance() {
        const name = prompt("Enter name of instance to delete (cannot be current instance):");
        if (name === null) return null;
        // websocket.send(`ADMIN:inst-delete:${name}`);
        req("/api/instance/delete", "DELETE", { name });
    }

    function cloneInstance() {
        const name = prompt("Enter name of clone of current:");
        if (name === null) return null;
        // websocket.send(`ADMIN:inst-clone-to:${name}`);
        req("/api/instance/clone", "POST", { name });
    }

    var waiting = false;

    function waitForInstanceUpdate() {
        document.getElementById("instance-management").style.opacity = 0.5;
        waiting = true;
    }

    function instanceUpdate(func) {
        if (waiting) {
            alert("Waiting for previous write to finish ...");
            return;
        }
        const ret = func();
        if (ret === null) return;
        waitForInstanceUpdate();
        return ret;
    }

    function configUpdate(newConfig) {
        // websocket.send(`ADMIN:config-update:${JSON.stringify(newConfig)}`);
        req("/api/config/update", "POST", newConfig);
    }

    function fullDateFmt(date, millis = false) {
        var str = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")} ${date.toLocaleTimeString("en-US", { hour12: false })}`;
        if (millis) str += "." + date.getMilliseconds().toString().padStart(3, "0");
        return str;
    }

    function pushLog(msg) {
        const line = document.createElement("p");
        line.innerText = `[${fullDateFmt(new Date, millis = true)}] ${msg}`;
        const logs = document.getElementById("logs");
        logs.prepend(line);
    }

    websocket.onopen = e => {
        console.log("CONNECTED");
        pushLog("[socket] connected")
        info.connectionStatus = "connected (not admin)";
        updateInfo();
        document.getElementById("button-verify").disabled = false;
    };

    websocket.onclose = e => {
        console.log("DISCONNECTED");
        pushLog("[socket] disconnected")
        reset();
    };

    websocket.onmessage = e => {
        console.log(`RECEIVED: ${e.data}`);
        pushLog(`[socket] received: ${e.data}`);
        if (e.data.startsWith("ADMIN:")) {
            if (e.data == "ADMIN:OVERRIDDEN") {
                websocket.close();
                document.getElementById("msg").innerText = "Session overriden - another client has connected as admin, reload to reconnect"
                return;
            } else if (e.data.startsWith("ADMIN:INSTANCES:")) {
                const instanceData = JSON.parse(e.data.slice("ADMIN:INSTANCES:".length));
                const segment = document.getElementById("instances");
                while (segment.children.length) {
                    segment.removeChild(segment.children[0]);
                }
                for (const name of instanceData["instances"]) {
                    const btn = document.createElement("button");
                    btn.innerText = name;
                    btn.value = name;
                    btn.onclick = e => instanceUpdate(() => {
                        // websocket.send(`ADMIN:inst-switch:${e.target.value}`);
                        req("/api/instance/switch", "POST", { name });
                    });
                    segment.appendChild(btn);
                    if (name == instanceData["current"]) {
                        btn.classList.add("selected");
                    }
                }
            } else if (e.data == "ADMIN:DONE") {
                waiting = false;
                document.getElementById("instance-management").style.opacity = 1;
            } else if (e.data.startsWith("ADMIN:CLIENTS:")) {
                const data = JSON.parse(e.data.slice("ADMIN:CLIENTS:".length));
                updateClientData(data);
            } else if (e.data.startsWith("ADMIN:SERVERCONFIG:")) {
                info.connectionStatus = "connected as admin";
                serverConfig = JSON.parse(e.data.slice("ADMIN:SERVERCONFIG:".length));
                updateInfo();
            } else if (e.data.startsWith("ADMIN:request-session:")) {
                const sessionName = e.data.slice("ADMIN:request-session:");
                const ans = prompt(`[Session request] \"${sessionName}\".\n\nm`)
            }
        }
    }

    function uasniff(userAgentString) {
        const ua = userAgentString.toLowerCase();
        
        const result = {
            os: null,
            deviceType: null,
            browser: null,
            mobile: false
        };
        
        if (/iphone|ipod|ipad/.test(ua)) {
            result.os = 'iOS';
        } else if (/windows/.test(ua)) {
            result.os = 'Windows';
        } else if (/macintosh|mac os x/.test(ua)) {
            result.os = 'MacOS';
        } else if (/android/.test(ua)) {
            result.os = 'Android';
        } else if (/linux/.test(ua)) {
            result.os = 'Linux';
        }
        
        if (/mobile|android|iphone|ipad|ipod/.test(ua)) {
            result.mobile = true;
            if (/ipad/.test(ua)) {
                result.deviceType = 'Tablet';
            } else {
                result.deviceType = 'Mobile';
            }
        } else {
            result.deviceType = 'Desktop';
        }
        
        if (/chrome\/([0-9]+)/.test(ua)) {
            result.browser = 'Chrome';
        } else if (/firefox\/([0-9]+)/.test(ua)) {
            result.browser = 'Firefox';
        } else if (/safari\/([0-9]+)/.test(ua)) {
            result.browser = 'Safari';
        } else if (/edge\/([0-9]+)/.test(ua)) {
            result.browser = 'Edge';
        }
        
        return result;
    }

    function updateClientData(data) {
        const tbody = document.getElementById("clients-data");
        while (tbody.children.length) {
            tbody.removeChild(tbody.children[0]);
        }
        for (const entry of data) {
            const tr = document.createElement("tr");

            const tdTimestamp = document.createElement("td");
            tdTimestamp.innerText = fullDateFmt(new Date(entry.timestamp));
            tr.appendChild(tdTimestamp);

            const tdUA = document.createElement("td");
            const sniffed = uasniff(entry.userAgent);
            tdUA.innerText = `${sniffed.os}, ${sniffed.browser}`;
            tr.appendChild(tdUA);

            const tdRole = document.createElement("td");
            if (entry.role === undefined) {
                tdRole.innerText = "Unknown";
            } else {
                tdRole.innerText = entry.role;
            }
            tr.appendChild(tdRole);
            
            const tdExpireIn = document.createElement("td");
            if (entry.role == "Admin") {
                tdExpireIn.innerText = "Admin";
            } else if (entry.expireIn === undefined) {
                tdExpireIn.innerText = "None";
            } else if (typeof entry.expireIn === "string" && entry.expireIn.startsWith("@admin:")) {
                tdExpireIn.innerText = "Granted " + fullDateFmt(new Date(parseInt(entry.expireIn.slice("@admin:".length))))
            } else {
                tdExpireIn.innerText = "Until " + fullDateFmt(new Date(entry.expireIn));
            }
            tr.appendChild(tdExpireIn);

            const tdAction = document.createElement("td");

            // [Disconnect]
            const btnDisconnect = document.createElement("button");
            btnDisconnect.innerText = "Disconnect";
            btnDisconnect.onclick = () => {
                // alert(entry.id);
                websocket.send(`ADMIN:clients-disconnect:${entry.id}`);
            };
            tdAction.appendChild(btnDisconnect);
            
            // [Allow input]
            const btnAllowInput = document.createElement("button");
            btnAllowInput.innerText = "Allow input";
            btnAllowInput.onclick = () => {
                websocket.send(`ADMIN:clients-allow-input:${entry.id}`);
            };
            tdAction.appendChild(btnAllowInput);

            tr.appendChild(tdAction);

            const tdFullId = document.createElement("td");
            tdFullId.innerText = entry.id;
            tr.appendChild(tdFullId);

            tbody.appendChild(tr);
        }
    }

    function createToken() {
        const token = prompt("Enter access token (at least 4 chars):");
        if (token === null) return;
        const tonight = new Date;
        tonight.setHours(23, 59, 59);
        const dateString = prompt("Enter expiry date (YYYY-MM-DD hh:mm:ss):", fullDateFmt(tonight));
        if (dateString === null) return;
        const expireIn = Date.parse(dateString);
        req("/api/token/create", "POST", { token, expireIn });
        // websocket.send("ADMIN:create-token:" + JSON.stringify({
        //     token,
        //     expireIn,
        // }));
    }

    const reset = () => {
        info.connectionStatus = "disconnected";
        info.connectionId = "unknown";
        info.serverStatus = "unknown";
        updateInfo();
        document.getElementById("button-verify").disabled = true;
    };

    document.addEventListener("DOMContentLoaded", () => {
        reset();
        info.connectionStatus = "connecting ...";
        updateInfo();
    });
</script>
